# Git Branchの動作の確認とGitの考え方に関する考察

## Branch動作の確認
- test.txt: テキストなし。

### [master]
testブランチを作成。
testブランチへ移動。

### [test]
ステージング/コミット
(test.txt: テキスト無し)
masterブランチへ移動

### [master]
- test.txt:編集/ステージング(編集状態①)
testブランチへ移動しようとするがabortされる
masterブランチでコミット
testブランチへ移動。

### [test]
- test.txt： テキストなし状態
masterブランチへ移動

### [master]
- text.txt: 編集状態①に戻る
test2ブランチを新規作成
test2ブランチへ移動→可能

### [test2]
- text.txt：編集状態①
masterブランチへ移動

### [master]
- text.txt: 編集状態①
testブランチへ移動

### [test]
- test.txt： テキスト無し状態
git merge test2
- test.txt： 編集状態①に変化＋コミット状態になる。
- test.txt: 編集状態②へ変更(未保存)
test2ブランチへ移動→可能(コミット位置が同一の場合は編集中のものも破棄されない)

### [test2]
- test.txt: 編集状態②へ変更(未保存)
testブランチへ移動→可能

### [test]
- test.txt： 編集状態②で保存
test2ブランチへ移動しようとするがabortされる
testブランチでステージング/コミット
test2ブランチへ移動→可能

## 以上から分かったこと。
各ブランチは最終コミットの内容とワーキングエリア(全ファイル保存)の内容が同一の場合＝ワーキングツリークリーンの状態のみ、他のブランチへの移動が許される。(ブランチを移動したときに編集が上書きされて失われるのを防ぐためだと思われる)
ただし、未保存の場合、相違をGitが感知できずブランチを移動できてしまう。
その状態で予定とは異なるブランチで保存するミスを起こすと、本来コミットしたかったブランチに戻ってステージング/コミット作業が行えない。予定のブランチに戻るには、保存したものを破棄して直前のコミットバージョンに戻すか、そのブランチでコミットを済ませなければならない。

細かくブランチを立てて作業を進めた方がよいが、ファイル別にブランチを立てる運用だと、複数ファイルを並行して編集するような作業が必要な場合、混乱に陥る。ブランチは、作業のテーマ別に立てて運用すべきである。

Gitの特徴が、どのコミット時点にでも戻れる点だけをとれば本来ブランチという概念は不要で、セーブポイントのリスト＝コミットのリストがあればよい。しかし、それではそのセーブポイントが一時的なもので、どのセーブポイントが決定稿なのかが分かりにくくなる。そこで、ブランチ＝一つの目的の流れ、という概念を導入し、ブランチの最終コミット＝一つの目的の最終結果、として分かりやすくしたものと思われる。

とすると、一つの目標にむけた作業が(完成ではなくとも)一段落するまで、ブランチは行ったり来たりすべきものではない。そして完成した暁にはマージレビューを行ってマージする、ということだ。

以上を考慮すると、「編集するから」といって容易にブランチを作るのではなく、事前に何をゴールとするか、を想定してブランチを作る必要がある、ということだ。

そして、該当する目標のブランチにいるかどうかを意識して、編集作業を開始する。この意識さえ持てば、誤ったブランチにファイルを保存してしまい身動きが取れなくなる、といった事態を避けることができる。



